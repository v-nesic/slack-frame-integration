<!DOCTYPE html>
<html>
<head>
</head>

<body>

<h1>Connecting to the requested FRAME instance</h1>
<h2>Current session</h2>
<div id="current_session"></div>
<h2>Previous sessions</h2>
<div id="connected_sessions"></div>
<h2>Capacity info</h2>
<div id="capacity_info"></div>

<script src="https://rawgit.com/ScottHamper/Cookies/1.2.2/dist/cookies.min.js"></script>
<script src="https://app.fra.me/embed/frame_app.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script>

// Track sessions which are not properly closed
function getConnectedSessions() {
	sessions = Cookies.get('connectedFrameSessions');
	return sessions != undefined ? sessions.split(':') : [];
}

function addActiveSession(sessionId) {
    if (sessionId != undefined && sessionId != null) {
        connectedSessions = getConnectedSessions();
        for(i = 0; i < connectedSessions.length; ++i) {
            if (sessionId == connectedSessions[i]) {
                return connectedSessions;
            }
        }
        connectedSessions.push(sessionId);
        Cookies.set('connectedFrameSessions', connectedSessions.join(':'), {expires: 3600});
        return connectedSessions;
    } else {
        return []
    }
}

function removeActiveSession(sessionId) {
    if (sessionId != undefined && sessionId != null) {
        connectedSessions = getConnectedSessions();
        for(i = 0; i < connectedSessions.length; ++i) {
            if (sessionId == connectedSessions[i]) {
                connectedSessions.splice(i, 1);
                Cookies.set('connectedFrameSessions', connectedSessions.join(':'), {expires: 3600});
            }
        }
        return connectedSessions;
    } else {
        return []
    }
}

function showConnectedSessions(sessions) {
    var table = $('<table/>').addClass('connectedSessionsTable');
    for(i = 0; i < sessions.length; ++i) {
        var row = $('<tr/>').addClass('connectedSessionsTableRow');
        cell = $('<td/>');
        cell.html(sessions[i]);
        row.append(cell);
        //row.append($('<td>' + sessions[i] + '</td>'));
        row.append($('<td><input type="button" id="connect_session' + i + '" value="Connect"></td>'));
        row.append($('<td><input type="button" id="forget_session' + i + '" value="Forget"></td>'));
        table.append(row);
    }
}

// create frame app object and bind events
var frameApp = new frameApi.FrameApp({
	hash: '{{application_id}}', // required
	fileName: '{{file_url|safe}}', // URL to a file to open on launch // optional
{% if pool_id %}
	poolId: {{pool_id}}, // ID of a desired pool // optional
{% else %}
	// poolId: ID of a desired pool // optional
{% endif %}
	// userData: A string containing user data, // optional
	// maxDuration: Maximum session duration (minutes), // optional
	// showErrors: Flag used to prevent player from showing errors // optional
	// hidePlayerFooter: Flag used to hide footer of the player // optional
	// headerHeight: Inserts header above player for custom elements. // optional
	// You can place elements in the header by using id='mf2-header'
	// autostart: Flag used to start a session when page is loaded // optional
});

// bind events
frameApp.bind(FrameApp.EVENT_ERROR, function(e) {
	alert(e.message);
});
frameApp.bind(FrameApp.EVENT_LOADING_STARTED, function() {
	console.info('Loading started');
});
frameApp.bind(FrameApp.EVENT_LOADING_DONE, function() {
	console.info('Loading done.');
});
frameApp.bind(FrameApp.EVENT_CLOSED, function() {
	console.info('Session closed.');
	showConnectedSessions(removeActiveSession(frameApp.sessionId));
});
frameApp.bind(FrameApp.EVENT_BROADCAST_SESSION_ID, function(sessionId) {
	console.info('Broadcast session id: ' + sessionId);
	showConnectedSessions(addActiveSession(sessionId));
});
frameApp.bind(FrameApp.EVENT_BROADCAST_SHARE_URL, function(url) {
	console.info('Broadcast share url: ' + url);
});
frameApp.bind(FrameApp.EVENT_TERMINAL_SHOWN, function() {
	console.info('Terminal shown!');
});
frameApp.bind(FrameApp.EVENT_OPEN_URL, function(url) {
	console.info("Open url: " + url);
});

$(document).ready(function() {
	frameApp.bind(FrameApp.EVENT_READY, function() {
	    showConnectedSessions(getConnectedSessions());

		// start a new session
		console.log("Starting session");
		frameApp.startSession({
			connectOnStart: true,
			waitForInstance: true // TODO: reconsider this
		})
		.then(function() {
			console.log("Session started");
		})
		.catch(function(error) {
			console.error("Failed to start session: " + error.toString());
		});

		// try to close current connection before the page is unloaded
		// to avoid stale instances
		//$(window).bind('beforeunload', function() {
		//    try {
		//        frameApp.closeSession();
		//        console.log("Closing current session");
		//    } catch (err) {
		//        console.log("Failed to close current session: " + err.toString());
		//    }
		//})

		// Called each 3 seconds to return basic session parameters
		setInterval(function() {
		    if (frameApp.sessionId != undefined && frameApp.sessionId != null) {
    		    $('#current_session').html(frameApp.sessionId);
		    } else {
    		    $('#current_session').html('');
		    }
			console.log("Getting session id: " + frameApp.sessionId);
			frameApp.getCapacityInfoAsync().then(function(capacityInfo) {
				console.log("Capacity info received:");
				console.log(capacityInfo);
				var props = ['available_instances', 'running_instances', 'coming_soon'];
				var stats = [];
				for(var i = 0; i < props.length; i++) {
					var property = props[i];
					stats.push(property + ': ' + capacityInfo[property]);
				}
				$('#capacity_info').html(stats.join('<br>'));
			});
		}, 3000);
	});
});

</script>

</body>
</html>